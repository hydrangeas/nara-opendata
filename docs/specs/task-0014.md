# 0014: JWTトークン検証ロジックの実装

## 説明
JWTトークンの詳細な検証ロジックの実装。署名検証、有効期限チェック、必須クレームの存在確認、トークンフォーマットの検証などを包括的に実装し、セキュアな認証基盤を構築する。

## タスク種別
- [x] 機能実装
- [ ] バグ修正
- [ ] リファクタリング
- [ ] テスト
- [ ] ドキュメント
- [ ] 調査

## 優先度
高

## 見積もり工数
[ストーリーポイント: 3] (約1日)

## 依存関係
- 前提タスク: #0012, #0013
- 関連タスク: #0015, #0016

## 受け入れ基準
- [ ] JWT署名検証が実装されている
- [ ] トークンの構造検証が実装されている
- [ ] 有効期限（exp）の検証が実装されている
- [ ] 発行時刻（iat）の検証が実装されている
- [ ] 必須クレームの存在確認が実装されている
- [ ] トークンのブラックリスト確認が実装されている（オプション）
- [ ] 詳細なエラー情報が提供されている
- [ ] セキュリティベストプラクティスに準拠している

## 技術的な詳細
### JWT検証サービス
```typescript
// src/infrastructure/auth/services/jwt-validator.service.ts
import { injectable } from "tsyringe";
import { jwtDecode, JwtPayload } from "jwt-decode";
import { createRemoteJWKSet, jwtVerify, errors as joseErrors } from "jose";
import { env } from "@/config/env";
import { Logger } from "pino";
import { Result } from "@/domain/errors/result";
import { DomainError, ErrorType } from "@/domain/errors/domain-error";

export interface JWTValidationResult {
  isValid: boolean;
  payload?: JwtPayload;
  error?: string;
  errorCode?: string;
}

@injectable()
export class JWTValidatorService {
  private readonly JWKS_URI: string;
  private readonly jwks: ReturnType<typeof createRemoteJWKSet>;
  private readonly issuer: string;
  private readonly audience: string;
  private readonly clockTolerance: number = 5; // 5秒の時計のずれを許容

  constructor(private readonly logger: Logger) {
    this.issuer = `${env.supabaseUrl}/auth/v1`;
    this.audience = "authenticated";
    this.JWKS_URI = `${env.supabaseUrl}/auth/v1/.well-known/jwks.json`;
    
    // JWKSエンドポイントからの公開鍵取得設定
    this.jwks = createRemoteJWKSet(new URL(this.JWKS_URI), {
      cooldownDuration: 600_000, // 10分間のキャッシュ
    });
  }

  /**
   * JWTトークンを完全に検証
   */
  async validateToken(token: string): Promise<Result<JwtPayload>> {
    try {
      // 1. トークン形式の基本検証
      const formatValidation = this.validateTokenFormat(token);
      if (formatValidation.isFailure) {
        return formatValidation;
      }

      // 2. 署名検証とクレーム検証
      const { payload } = await jwtVerify(token, this.jwks, {
        issuer: this.issuer,
        audience: this.audience,
        clockTolerance: this.clockTolerance,
      });

      // 3. カスタムクレームの検証
      const customValidation = this.validateCustomClaims(payload);
      if (customValidation.isFailure) {
        return customValidation;
      }

      // 4. 追加のセキュリティチェック
      const securityValidation = await this.performSecurityChecks(payload);
      if (securityValidation.isFailure) {
        return securityValidation;
      }

      this.logger.info({
        userId: payload.sub,
        tokenId: payload.jti,
      }, "JWT token validated successfully");

      return Result.ok(payload as JwtPayload);
    } catch (error) {
      return this.handleVerificationError(error);
    }
  }

  /**
   * トークンの形式を検証
   */
  private validateTokenFormat(token: string): Result<void> {
    if (!token || typeof token !== "string") {
      return Result.fail(
        new DomainError(
          "INVALID_TOKEN_FORMAT",
          "Token must be a non-empty string",
          ErrorType.VALIDATION
        )
      );
    }

    const parts = token.split(".");
    if (parts.length !== 3) {
      return Result.fail(
        new DomainError(
          "MALFORMED_TOKEN",
          "Token must have three parts separated by dots",
          ErrorType.VALIDATION
        )
      );
    }

    // Bearer プレフィックスが含まれていないことを確認
    if (token.toLowerCase().startsWith("bearer ")) {
      return Result.fail(
        new DomainError(
          "TOKEN_PREFIX_INCLUDED",
          "Token should not include Bearer prefix",
          ErrorType.VALIDATION
        )
      );
    }

    return Result.ok(undefined);
  }

  /**
   * カスタムクレームを検証
   */
  private validateCustomClaims(payload: any): Result<void> {
    // 必須フィールドの存在確認
    if (!payload.sub) {
      return Result.fail(
        new DomainError(
          "MISSING_SUB_CLAIM",
          "Token is missing required 'sub' claim",
          ErrorType.VALIDATION
        )
      );
    }

    // app_metadataの存在確認
    if (!payload.app_metadata) {
      return Result.fail(
        new DomainError(
          "MISSING_APP_METADATA",
          "Token is missing required 'app_metadata' claim",
          ErrorType.VALIDATION
        )
      );
    }

    // ユーザーロールの検証（オプション）
    if (payload.role && !this.isValidRole(payload.role)) {
      return Result.fail(
        new DomainError(
          "INVALID_ROLE",
          `Invalid role: ${payload.role}`,
          ErrorType.VALIDATION
        )
      );
    }

    return Result.ok(undefined);
  }

  /**
   * 追加のセキュリティチェック
   */
  private async performSecurityChecks(payload: any): Promise<Result<void>> {
    // 1. トークンの年齢チェック（あまりに古いトークンを拒否）
    const tokenAge = Date.now() / 1000 - payload.iat;
    const maxTokenAge = 24 * 60 * 60; // 24時間

    if (tokenAge > maxTokenAge) {
      return Result.fail(
        new DomainError(
          "TOKEN_TOO_OLD",
          "Token was issued too long ago",
          ErrorType.UNAUTHORIZED,
          { issuedAt: new Date(payload.iat * 1000).toISOString() }
        )
      );
    }

    // 2. nbf (not before) クレームのチェック
    if (payload.nbf && payload.nbf > Date.now() / 1000 + this.clockTolerance) {
      return Result.fail(
        new DomainError(
          "TOKEN_NOT_YET_VALID",
          "Token is not yet valid",
          ErrorType.UNAUTHORIZED,
          { notBefore: new Date(payload.nbf * 1000).toISOString() }
        )
      );
    }

    // 3. jti（JWT ID）によるトークンの一意性チェック（ブラックリスト確認）
    if (payload.jti) {
      const isBlacklisted = await this.checkTokenBlacklist(payload.jti);
      if (isBlacklisted) {
        return Result.fail(
          new DomainError(
            "TOKEN_REVOKED",
            "Token has been revoked",
            ErrorType.UNAUTHORIZED
          )
        );
      }
    }

    return Result.ok(undefined);
  }

  /**
   * jose ライブラリのエラーを適切なドメインエラーに変換
   */
  private handleVerificationError(error: unknown): Result<JwtPayload> {
    if (error instanceof joseErrors.JWTExpired) {
      return Result.fail(
        new DomainError(
          "TOKEN_EXPIRED",
          "Token has expired",
          ErrorType.UNAUTHORIZED,
          { expiredAt: error.claim }
        )
      );
    }

    if (error instanceof joseErrors.JWTClaimValidationFailed) {
      return Result.fail(
        new DomainError(
          "CLAIM_VALIDATION_FAILED",
          `Claim validation failed: ${error.claim}`,
          ErrorType.UNAUTHORIZED,
          { claim: error.claim, reason: error.reason }
        )
      );
    }

    if (error instanceof joseErrors.JWSSignatureVerificationFailed) {
      return Result.fail(
        new DomainError(
          "INVALID_SIGNATURE",
          "Token signature verification failed",
          ErrorType.UNAUTHORIZED
        )
      );
    }

    if (error instanceof joseErrors.JWKSNoMatchingKey) {
      return Result.fail(
        new DomainError(
          "NO_MATCHING_KEY",
          "No matching key found in JWKS",
          ErrorType.UNAUTHORIZED
        )
      );
    }

    this.logger.error({
      error: error instanceof Error ? error.message : "Unknown error",
    }, "Unexpected JWT verification error");

    return Result.fail(
      new DomainError(
        "TOKEN_VERIFICATION_FAILED",
        "Token verification failed",
        ErrorType.UNAUTHORIZED
      )
    );
  }

  /**
   * 有効なロールかチェック
   */
  private isValidRole(role: string): boolean {
    const validRoles = ["authenticated", "anon", "service_role"];
    return validRoles.includes(role);
  }

  /**
   * トークンブラックリストをチェック（実装は簡略化）
   */
  private async checkTokenBlacklist(jti: string): Promise<boolean> {
    // 実際の実装では、Redisやデータベースでブラックリストを管理
    // ここでは常にfalseを返す
    return false;
  }
}
```

### 統合テスト
```typescript
// src/infrastructure/auth/services/__tests__/jwt-validator.integration.test.ts
import { JWTValidatorService } from "../jwt-validator.service";
import { createLogger } from "@/infrastructure/logging/logger";
import { SignJWT } from "jose";
import { generateKeyPair } from "crypto";
import { promisify } from "util";

describe("JWTValidatorService Integration", () => {
  let validator: JWTValidatorService;
  
  beforeEach(() => {
    const logger = createLogger();
    validator = new JWTValidatorService(logger);
  });

  it("should reject expired tokens", async () => {
    const expiredToken = createMockToken({
      exp: Math.floor(Date.now() / 1000) - 3600, // 1時間前
    });

    const result = await validator.validateToken(expiredToken);
    
    expect(result.isFailure).toBe(true);
    expect(result.getError().code).toBe("TOKEN_EXPIRED");
  });

  it("should reject tokens with invalid format", async () => {
    const invalidTokens = [
      "not.a.token",
      "Bearer eyJhbGc...",
      "",
      "a.b", // 2パートのみ
    ];

    for (const token of invalidTokens) {
      const result = await validator.validateToken(token);
      expect(result.isFailure).toBe(true);
    }
  });

  it("should validate time-based claims correctly", async () => {
    const futureToken = createMockToken({
      nbf: Math.floor(Date.now() / 1000) + 3600, // 1時間後から有効
    });

    const result = await validator.validateToken(futureToken);
    
    expect(result.isFailure).toBe(true);
    expect(result.getError().code).toBe("TOKEN_NOT_YET_VALID");
  });
});

// モックトークン生成ヘルパー
function createMockToken(claims: any): string {
  // 実際のテストでは適切なモックライブラリを使用
  return "mock.jwt.token";
}
```